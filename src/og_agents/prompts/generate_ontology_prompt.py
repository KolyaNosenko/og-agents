from langchain_core.prompts import PromptTemplate

from src.og_agents.documents import OntologySourceDocument

PROMPT_TEMPLATE = """
Твоє завдання — зробити внесок у створення добре структурованої онтології, прочитавши інформацію, що міститься в наданих документах, вимогах та обмеженнях (якщо вони є).
Для вирішення цієї задачі бери кожне competency question (компетентнісне питання) по черзі. Далі згенеруйте RDF так, щоб онтологія могла відповідати на це competency question. Ваш результат має бути валідною онтологією у RDF, яка може відповісти на всі надані питання компетентності.
Прочитай ці визначення, щоб краще розібратися з поняттями:
Питання компетентності — це питання природною мовою, які задають вимоги до онтології та на які ця онтологія повинна вміти відповідати.
Класи (Classes) — це ключові слова/класи, які стануть типами вузлів (node types) в графі знань онтології. Спробуй видобути всі класи; окрім того, класи можуть бути створені для реїфікації (reification).
Для представлення онтології використовуй синтаксис Turtle.
Ієрархії задаються через rdfs:subClassOf у Turtle-синтаксисі. Їх можна використовувати, щоб класифікувати подібні класи під одним суперкласом. Для цього ви можете знаходити схожі вузли й створювати/використовувати клас як їхнього батька. Наприклад, додавання вузла "Клас_Працівник" є хорошим проміжним рівнем і суперкласом для "Клас_Професор" та "Клас_Адміністратор", якщо спираючись на документи необхідно моделювати онтологію університету. Зазвичай глибша ієрархія — краще. Один зі способів — категоризувати класи у кілька груп і створювати для них суперкласи. Важливо: імена класів мають префікс Клас_, наприклад Клас_Професор. Також май на увазі, що для кожного класу можна додавати Equivalent To (еквівалентність), загальні аксіоми класів (General class axioms), Disjoint with (несумісність), та Disjoint Union of (диз’юнктне об’єднання).
У моделюванні онтології для кожного питання компетентності, коли стикаєшся зі складними сценаріями, що включають більше ніж дві сутності або комбінацію сутностей і типів даних (datatypes), застосовуй реїфікацію. Тобто створюй pivot class (проміжний клас) як посередника між цими сутностями, щоб коректно відобразити нюансні відношення. Наприклад, для «користувач отримав доступ до ресурсу в певний час» створіть pivot class на кшталт Клас_КористувачВикориставРесурс, пов’язану з користувачем, ресурсом та конкретним часом доступу через Клас_ВзаємодіяКористувачаЗРесурсом, замість того щоб напряму з’єднувати користувача одночасно з ресурсом і часом.
Далі тобі потрібно створити властивості (owl:Property). На цьому кроці використовуй класи з попереднього етапу й створюй об’єктні (object) та дататипні (data) властивості, щоб з’єднати їх і сформувати онтологію. Завжди виводь Turtle-синтаксис. Якщо для моделювання питання компетентності між більш ніж 2 поняттями потрібні додаткові класи — сміливо додавай більше pivot класів (класів для реїфікації). Намагайся знайти якнайбільше зв’язків, читаючи питання компетентності, документи та обмеження. На цьому етапі можеш створювати і data, і object properties.
Data properties — між класами (або класами в ієрархії) та типами даних, такими як xsd:string, xsd:integer, xsd:decimal, xsd:dateTime, xsd:date, xsd:time, xsd:boolean, xsd:byte, xsd:double, xsd:float тощо. Наприклад, у домені університету: вік a owl:Property ; rdfs:domain :Вчитель ; rdfs:range xsd:integer.
Object properties — між класами. Намагайся знайти якнайбільше зв’язків, читаючи питання компетентності і документи. Можеш використовувати rdfs:subPropertyOf для створення ієрархій відношень. Для моделювання властивостей (object або data) за потреби використовуй характеристики відношень: Functional, Inverse functional, Transitive, Symmetric, Asymmetric, Reflexive, Irreflexive. Також гнучко задавай domain і range: можеш ставити у domain/range Клас_клас1 або Клас_клас2, або використовувати disjoint with, або інверсію між відношеннями.
Часто забувають додати відношення, пов’язані з реїфікацією: у RDF реїфікації точне моделювання є ключовим, особливо коли потрібно обробляти багатокомпонентні сценарії, де простих бінарних зв’язків недостатньо. Наприклад, твердження «користувач використав ресурс у певний час». Хоча на перший погляд воно виглядає як прямий зв’язок між «користувачем» і «ресурсом», насправді воно містить три сутності: «користувач», «ресурс» і «час». Пряме з’єднання «користувача» одночасно з «ресурсом» і «часом» не передає суті, бо неясно, який саме ресурс було використано користувачем у конкретний час. Щоб це виправити, потрібен складніший підхід: pivot class, наприклад Клас_ВикористанняРесурсу. Цей pivot class виступає посередником, з’єднуючи Клас_Користувач і Клас_Ресурс. Крім того, він включає властивість часу, щоб зафіксувати точний момент використання. Застосовуючи цей метод, можна узгоджено змоделювати твердження, гарантуючи однозначне представлення взаємодії користувача з конкретним ресурсом у конкретний час. Це підкреслює важливість патернів проєктування онтологій і потребу в проміжних вузлах при моделюванні складних зв’язків, що включають кілька сутностей або суміш сутностей і типів даних.
Під час застосування обмежень (restrictions) можеш використовувати:
owl:equivalentClass [ rdf:type owl:Restriction ; owl:onProperty :{{relation}} ; owl:allValuesFrom :{{Class}} ] ;
так ти можеш задавати обмеження для класів, наприклад «клас Клас_клас1 — єдиний клас, що використовує відношення Відношення1». Або можете задавати «м’якші» обмеження через owl:someValuesFrom. Також можна використовувати загальні аксіоми класів:
[ rdf:type owl:Restriction ; owl:onProperty :Відношення1 ; owl:someValuesFrom :Клас_клас1 ; rdfs:subClassOf :Клас_клас2 ]
коли ти хочеш накласти обмеження на визначення класу на основі його відношення, і це визначення є необхідним, але недостатнім (якщо достатнє — тоді це було б еквівалентно owl:equivalentClass).

Ось префікси:
@prefix : [http://www.example.org/test#](http://www.example.org/test#) .
@prefix rdf: [http://www.w3.org/1999/02/22-rdf-syntax-ns#](http://www.w3.org/1999/02/22-rdf-syntax-ns#) .
@prefix rdfs: [http://www.w3.org/2000/01/rdf-schema#](http://www.w3.org/2000/01/rdf-schema#) .
@prefix xsd: [http://www.w3.org/2001/XMLSchema#](http://www.w3.org/2001/XMLSchema#) .
@prefix owl: [http://www.w3.org/2002/07/owl#](http://www.w3.org/2002/07/owl#) .

Важливо:
1. Поверни ЛИШЕ фінальний RDF, без будь-якого іншого тексту.
2. Прив’яжи усі ресурси, що додаються до онтології, до префікса ":".

Документи: {documents}

Питання компетентності:
{competency_questions}

Порада:
Ось типові помилки, яких можна припустити:
1. забути додати префікси на початку коду;
2. забути виписати pivot-класи на початку;
3. ваш вивід може бути приєднаний до попереднього RDF-виводу, тому не пишіть повторювані слова, класи тощо;
4. зазвичай забувають написати назву реїфікації (pivot), яку хочеш створити, на початку виводу;
5. у реїфікації вузол реїфікації (pivot class) з’єднується з усіма пов’язаними класами через object properties, а не через subClassOf. Він може бути підкласом чогось, але для реїфікації йому потрібні object properties.

Типові помилки при витягуванні класів:
1. помилка: не витягнути всі класи й пропустити багато з них (класи можна знайти в документах, або питанні компетентності, або в обмеженнях);
2. повернути порожню відповідь;
3. додавати коментарі або пояснення;
4. витягувати атрибути на кшталт 'Date' або 'integer' як класи — неправильно, бо це data properties;
5. не використовувати RDF-реїфікацію: не витягувати pivot-класи для моделювання відношення між класами (більше ніж один клас і одна data property, або більше ніж два класи);
6. витягувати індивідів із тексту як клас;
7. pivot class не є підкласом своїх компонентів.

Типові помилки у витягуванні ієрархії:
1. створювати онтологію для неіснуючих класів: створювати новий «листок» і розгортати його до кореня;
2. повертати порожню або дуже коротку відповідь;
3. додавати коментарі або пояснення;
4. витягувати атрибути типу date, time, string names, які належать до data properties;
5. забувати ставити "" навколо рядків у кортежах.

Типові помилки в object_properties:
1. повертати нові змінні з чимось, окрім object_properties;
2. повертати порожню або дуже коротку відповідь;
3. додавати коментарі або пояснення;
4. коли створено pivot class, усі пов’язані класи мають вказувати на нього (напрямок зв’язку: від класів (domain) «до» pivot class (range)).

Типові помилки в data_properties:
1. повертати нові змінні з чимось, окрім data_properties;
2. повертати порожню або дуже коротку відповідь;
3. додавати коментарі або пояснення.
"""

class GenerateOntologyPrompt:
    _template: PromptTemplate

    def __init__(self):
        self._template = PromptTemplate.from_template(PROMPT_TEMPLATE)

    def format(
            self,
            competency_questions: str,
            documents: list[OntologySourceDocument]
    ) -> str:
        formatted_documents = []

        for index, document in enumerate(documents):
            formatted_documents.append(document.to_prompt_format(index))

        joined_documents = '\n'.join(formatted_documents)

        return self._template.format(competency_questions=competency_questions, documents=joined_documents)